import {useState} from "react";
import './App.css';
import Image from "./Image";


/**
 * Entry point for the whole app
 * @returns {JSX.Element}
 * @constructor
 */
export default function Game(){
    // default value for display is empty, update when there's something to update
    const [display, setDisplay] = useState('');
    // default value for random phrase is empty, update when game starts
    const [phrase, setPhrase] = useState(' ');
    // default value for hiddenPhrase is generated by default, update whenever there's a good guess
    const [hiddenPhrase, setHiddenPhrase] = useState('')
    const [previousGuesses, setPreviousGuesses] = useState('');
    // health point for each game, default 10
    const [hp, setHp] = useState(10);

    // Input component call this function when form is submitted
    function handleSubmit(input){
        // if valid, go process, if not, do nothing
        const valid = checkValidation(input, previousGuesses);
        if (valid){

            // process input
            const processResult = processGuess(phrase, hiddenPhrase, input)
            // good guess, update the state of hiddenPhrase(uncover)
            if (processResult){
                // the arrow function form helps maintain the order and consistency of state updates
                setHiddenPhrase(() => processResult);
            } else {  // bad guess
                setHp(()=> hp - 1);
            }
        }
    }

    /**
     * helper method, check input validation
     * @param input new guess from user
     * @param previousGuesses buffer for duplication input checking
     * @returns {boolean}   whether the guess is legal input or not
     */
    function checkValidation(input , previousGuesses){
        if (!/[a-zA-Z]/.test(input.charAt(0))) {
            setDisplay(()=>"[TRY AGAIN] Only English Letter is Allowed!");
            return false;
        } else if (input.length !== 1) {
            setDisplay(()=>"[TRY AGAIN] Exact ONE Character for Each Guess!");
            return false;
        } else if (previousGuesses.includes(input.charAt(0))) {
            setDisplay(()=>"[TRY AGAIN] You've already guessed it before.");
            return false;
        } else {
            // update new valid guess previousGuesses
            const newPreviousGuesses = previousGuesses + input.charAt(0);
            setPreviousGuesses(()=> newPreviousGuesses);
            return true;
        }
    }

    /**
     * reset all state whenever the game restarts
     */
    function handleStart(){
        // generate randomPhrase and update the phrase state
        const newRandomPhrase = randomPhrase();
        setPhrase(() => newRandomPhrase);
        // generate hiddenPhrase base on the newRandomPhrase
        const newHiddenPhrase = generateHiddenPhrase(newRandomPhrase);
        setHiddenPhrase(() => newHiddenPhrase);

        // reset everything for new game
        setDisplay(()=> "New Game Started!");
        setPreviousGuesses(() => '');
        setHp(() => 10);
    }

    return (
        <div className='game'>
            {/*<img className="image" src={WOF} alt="WheelOfFortune"></img>*/}
            <Image />
            <button className="button" onClick={handleStart}>START</button>
            { hp === 0 ? <p>You Lose!</p> : (hiddenPhrase === phrase ? <p>You Win!</p> :<Display display={display}/>)}
            <HiddenPhrase hiddenPhrase={hiddenPhrase}/>
            <li>Remain HP: {hp}</li>
            <Input onFormSubmit={handleSubmit}/>
        </div>
    )
}

/**
 * Form component, handle form submission and get guess input
 * @param onFormSubmit  function being called when submit event triggered
 * @returns {JSX.Element}
 * @constructor
 */
function Input({onFormSubmit}){
    // default value for input is empty, update when form submitted
    const [inputValue, setInputValue] = useState('');

    const handleFormChange = function (event) {
        // update inputValue state
        setInputValue(() => event.target.value);
    }
    // function accept submitted event input as a parameter, called when related event happens
    const handleFormSubmit = function (event) {
        event.preventDefault();
        // call the function Game sent in
        onFormSubmit(inputValue);
        // reset the state for new input
        setInputValue(() => '');
    }
    // handleFormSubmit will be called, and onFormSubmit sent in by Game will be called next
    return (
        <form onSubmit={handleFormSubmit}>
            <label>
                Enter something:
                <input
                    type="text"
                    value={inputValue}
                    onChange={handleFormChange}
                />
            </label>
            <button className="button" type="submit">Submit</button>
        </form>
    )
}

/**
 * HiddenPhrase component, show latest hidden phrase
 * @param hiddenPhrase show hiddenPhrase state in HTML
 * @returns {JSX.Element}
 * @constructor
 */
function HiddenPhrase({hiddenPhrase}){
    return (
        <div>{hiddenPhrase}</div>
    )
}

/**
 * Display component, show logs of current game
 * @param display show display state in HTML
 * @returns {JSX.Element}
 * @constructor
 */
function Display({display}){
    return (
        <div className="display">{display}</div>
    )
}

/**
 * helper method, get random phrase from the list
 * @returns {string} random phrase
 */
function randomPhrase(){
    const phraseList = [
        "Change the world from here",
        "Be the change you wish to see",
        "Turn your wounds into wisdom"
    ]
    const ranIdx = Math.floor(Math.random() * phraseList.length);
    return phraseList[ranIdx];
}

/**
 * helper method, gen hiddenPhrase
 * @param phrase the covered phrase
 * @returns {*}
 */
function generateHiddenPhrase(phrase) {
    return phrase.replace(/[a-zA-Z]/g, '*');
    }

/**
 * helper method, process guess input, good or bad guess
 * @param phrase original random phrase
 * @param hiddenPhrase latest hiddenPhrase
 * @param input our new guess from user
 * @returns {string|boolean}
 */
function processGuess(phrase, hiddenPhrase, input){
    // remember, state should be immutable, copy it and return a new phrase instead of modifying it directly
    if (phrase.indexOf(input) === -1 && phrase.indexOf(input.toUpperCase()) === -1) {
            return false;
        }
    // for string assignment, this is a deep copy
    let newHiddenPhrase = hiddenPhrase;
    for (let i = 0; i < phrase.length; i++) {
        const char = phrase[i];
        if (char === input || char === input.toUpperCase()) {
            // newHiddenPhrase = newHiddenPhrase.substring(0, i) + char + newHiddenPhrase.substring(i + 1);
            newHiddenPhrase = newHiddenPhrase.substring(0, i) + char + newHiddenPhrase.substring(i + 1);
        }
    }
    // good guess, return new hiddenPhrase for Game component to set value
    return newHiddenPhrase;
}
